1) Файлы и структура

В корне: index.html, style.css, data.js, script.js, tf.min.js, u.data, u.item.

Подключения в <head> строго так:
style.css → tf.min.js → data.js → script.js.

2) Парсинг данных (data.js)

Считать ./u.item (pipe |) → собрать:

movies: [{rawId,index,title,genres[]}]

movieIndexByRawId: Map<rawItemId → i>

Считать ./u.data (TSV) → собрать:

userIndexByRawId: Map<rawUserId → u>

ratingsTriples: [{u,i,r}] (u/i — плотные индексы)

userRatedItems: Map<u, Set<i>>

STATS: {nUsers,nItems,nRatings,mean(μ)}

3) Модель MF (script.js)

Параметры по умолчанию (редактируемые в UI):
k=32, epochs=15, batch=2048, lr=0.01, lambda=1e-4.

Создать TF-переменные:

P:[U,k], Q:[I,k] ~ N(0,0.01), bu:[U]=0, bi:[I]=0, mu=μ.

Лосс: MSE по наблюдаемым + L2 на P,Q,bu,bi с lambda.

Оптимизатор: Adam(lr).

4) Обучение

Разбить ratingsTriples на train/val=90/10.

Учить батчами; после каждого батча: await tf.nextFrame(); все вычисления в tf.tidy(...).

Показывать в UI: epoch, Train RMSE, Val RMSE.

Кнопка Cancel прерывает цикл.

При повторном обучении — обязательно dispose() всех Variables/optimizer.

5) Инференс и рекомендации

Функция predictRating(u,i) = clip( μ + bu[u] + bi[i] + dot(P[u],Q[i]), 1,5 ).

recommendForUser(u, topN):

предсказать для всех i,

исключить userRatedItems.get(u),

отсортировать по предсказанию,

выдать Top-N c полями: Title, Genres, Predicted, Explain( μ | bᵤ | bᵢ | dot ).

6) UI (index.html + style.css)

Кнопки/поля:

#btn-load, статус #status, счётчики #stat-users/items/ratings/mu

#param-k #param-epochs #param-batch #param-lr #param-lambda

#btn-train #btn-cancel, прогресс #train-progress, метрики #train-epoch #train-trainrmse #train-valrmse

#user-select, #topn, #btn-recommend, таблица #results-table

Тёмная apple-like тема; контейнер max-width ~ 960px; доступные фокусы.

7) Производительность/надёжность

Batch ≤ 4096 (по умолчанию 2048).

Без утечек: все временные тензоры в tf.tidy; на перезапуск — disposeModel().

Исключить фризы: await tf.nextFrame() каждые 1–2 батча.

Читабельные ошибки парсинга/обучения; консоль чистая.

8) Acceptance Criteria

Данные загрузились; счётчики Users/Items/Ratings/μ корректны.

Обучение идёт; Train RMSE ↓, Val RMSE стабилизируется.

Рекомендации для пользователя с ≥5 оценками есть; уже оценённые исключены.

В «Explain» сходится: μ + bᵤ + bᵢ + dot ≈ Predicted (±1e-3).

Cancel работает; повторная тренировка без утечек/ошибок.

9) Запуск/деплой

Локально: python3 -m http.server → http://localhost:8000.

GitHub Pages: все файлы в корне/docs/; пути к данным — относительные (./u.data, ./u.item).
__________
Predicted

Это прогноз модели, какую оценку (1–5) поставит выбранный пользователь фильму, если посмотрит.
Сортируем по нему. Практика:

≥ 4.0 — сильный кандидат для показа;

3.5–3.9 — можно предложить как «попробовать»;

< 3.5 — низкий приоритет.
(Значение подрезано к диапазону 1–5.)

Explain (μ | bᵤ | bᵢ | dot)

Разложение прогноза на части. Они суммируются:
Predicted ≈ μ + bᵤ + bᵢ + dot.

μ (му) — средняя оценка по всей базе (общий фон, ~3.53).

bᵤ — сдвиг пользователя: насколько этот человек обычно ставит выше/ниже среднего.
Плюс → «щедрый», минус → «строгий».

bᵢ — сдвиг фильма: насколько сам фильм в целом любим/нелюбим всеми.
Плюс → «популярный/любимый», минус → «не заходит большинству».

dot — персональный матч пользователя и фильма. Это главный «персонализатор»:
большой плюс → фильм «в твоём вкусе», около нуля → нейтрально/не уверены, минус → вероятный мисс.

Как читать в продукте

Высокий Predicted из-за большого bᵢ, но маленького dot → «популярный, но не про пользователя». Хорош для витрины «топ популярного», хуже для «личных рекомендаций».

Высокий dot даже при умеренном bᵢ → по-настоящему персональная рекомендация — ставьте выше.

Отрицательный bᵤ (строгий пользователь) — планку показа стоит поднять (например, показывать от 4.1+).

Новые/редкие фильмы: bᵢ ≈ 0, dot ≈ 0 → прогноз вокруг μ + bᵤ (мало сигнала, осторожные рекомендации).

Если совсем просто:
μ — фон рынка, bᵤ — характер пользователя, bᵢ — «слава» фильма, dot — попадание во вкус.
